#!/bin/bash

# å…±é€šãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’èª­ã¿è¾¼ã¿
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/common.sh"

# ä½¿ç”¨æ–¹æ³•
usage() {
    echo -e "${CYAN}${BOLD}ğŸš€ Media-to-Media ãƒãƒƒãƒå‡¦ç†ãƒ„ãƒ¼ãƒ«${NC}"
    echo
    echo -e "${CYAN}ä½¿ç”¨æ–¹æ³•:${NC}"
    echo "  media-batch [ã‚ªãƒ—ã‚·ãƒ§ãƒ³] <å¤‰æ›ã‚¿ã‚¤ãƒ—> <å…¥åŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª> [å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª]"
    echo
    echo -e "${CYAN}å¤‰æ›ã‚¿ã‚¤ãƒ—:${NC}"
    echo -e "${WHITE}  éŸ³å£°å¤‰æ›:${NC}"
    echo "    mp3        MP4 â†’ MP3"
    echo "    mp3hq      MP4 â†’ MP3 (é«˜éŸ³è³ª)"
    echo "    aac        MP4 â†’ AAC"
    echo "    wav        MP4 â†’ WAV"
    echo -e "${WHITE}  ç”»åƒå¤‰æ›:${NC}"
    echo "    png        PDF â†’ PNG"
    echo "    pnghq      PDF â†’ PNG (é«˜å“è³ª)"
    echo "    jpg        PDF â†’ JPG"
    echo "    jpghq      PDF â†’ JPG (é«˜å“è³ª)"
    echo -e "${WHITE}  ãã®ä»–:${NC}"
    echo "    auto       ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã«åŸºã¥ã„ã¦è‡ªå‹•åˆ¤åˆ¥"
    echo
    echo -e "${CYAN}ã‚ªãƒ—ã‚·ãƒ§ãƒ³:${NC}"
    echo "  -h, --help       ã“ã®ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º"
    echo "  -r, --recursive  ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚‚å†å¸°çš„ã«å‡¦ç†"
    echo "  -f, --filter     ãƒ•ã‚¡ã‚¤ãƒ«åãƒ•ã‚£ãƒ«ã‚¿ï¼ˆæ­£è¦è¡¨ç¾ï¼‰"
    echo "  -j, --jobs       ä¸¦åˆ—å‡¦ç†æ•°ã‚’æŒ‡å®š"
    echo "  -q, --quality    å“è³ªã‚’æŒ‡å®š"
    echo "  -v, --verify     å¤‰æ›å¾Œã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œè¨¼"
    echo "  --dry-run        å®Ÿéš›ã®å¤‰æ›ã¯è¡Œã‚ãšã€å‡¦ç†å¯¾è±¡ã‚’è¡¨ç¤ºã®ã¿"
    echo "  --skip-existing  æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¹ã‚­ãƒƒãƒ—"
    echo "  --organize       å‡ºåŠ›ã‚’æ—¥ä»˜åˆ¥ã«æ•´ç†"
    echo
    echo -e "${CYAN}ä¾‹:${NC}"
    echo "  media-batch mp3 ~/Videos ~/Music"
    echo "  media-batch -r png ~/Documents/PDFs ~/Images"
    echo "  media-batch -j 8 -q 320k mp3hq ~/Downloads"
    echo "  media-batch --dry-run auto ~/Media"
}

# ã‚ªãƒ—ã‚·ãƒ§ãƒ³è§£æ
RECURSIVE=false
FILTER=""
JOBS=""
QUALITY=""
VERIFY_FILES=false
DRY_RUN=false
SKIP_EXISTING=false
ORGANIZE_OUTPUT=false
CONVERSION_TYPE=""
INPUT_DIR=""
OUTPUT_DIR=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            exit 0
            ;;
        -r|--recursive)
            RECURSIVE=true
            shift
            ;;
        -f|--filter)
            FILTER="$2"
            shift 2
            ;;
        -j|--jobs)
            JOBS="$2"
            shift 2
            ;;
        -q|--quality)
            QUALITY="$2"
            shift 2
            ;;
        -v|--verify)
            VERIFY_FILES=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --skip-existing)
            SKIP_EXISTING=true
            shift
            ;;
        --organize)
            ORGANIZE_OUTPUT=true
            shift
            ;;
        -*)
            echo -e "${RED}âŒ ä¸æ˜ãªã‚ªãƒ—ã‚·ãƒ§ãƒ³: $1${NC}"
            usage
            exit 1
            ;;
        *)
            if [[ -z "$CONVERSION_TYPE" ]]; then
                CONVERSION_TYPE="$1"
            elif [[ -z "$INPUT_DIR" ]]; then
                INPUT_DIR="$1"
            elif [[ -z "$OUTPUT_DIR" ]]; then
                OUTPUT_DIR="$1"
            else
                echo -e "${RED}âŒ ä½™åˆ†ãªå¼•æ•°: $1${NC}"
                usage
                exit 1
            fi
            shift
            ;;
    esac
done

# å¼•æ•°ãƒã‚§ãƒƒã‚¯
if [[ -z "$CONVERSION_TYPE" || -z "$INPUT_DIR" ]]; then
    usage
    exit 1
fi

# å…¥åŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒã‚§ãƒƒã‚¯
if [[ ! -d "$INPUT_DIR" ]]; then
    echo -e "${RED}âŒ ã‚¨ãƒ©ãƒ¼: å…¥åŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: $INPUT_DIR${NC}"
    exit 1
fi

# ä¸¦åˆ—å‡¦ç†æ•°è¨­å®š
if [[ -n "$JOBS" ]]; then
    PARALLEL_JOBS="$JOBS"
fi

# ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§å–å¾—
get_files() {
    local input_dir=$1
    local pattern=$2
    local files=()
    
    if [[ "$RECURSIVE" == "true" ]]; then
        if [[ -n "$FILTER" ]]; then
            mapfile -t files < <(find "$input_dir" -type f -name "$pattern" | grep -E "$FILTER")
        else
            mapfile -t files < <(find "$input_dir" -type f -name "$pattern")
        fi
    else
        if [[ -n "$FILTER" ]]; then
            mapfile -t files < <(find "$input_dir" -maxdepth 1 -type f -name "$pattern" | grep -E "$FILTER")
        else
            mapfile -t files < <(find "$input_dir" -maxdepth 1 -type f -name "$pattern")
        fi
    fi
    
    printf '%s\n' "${files[@]}"
}

# å‡ºåŠ›ãƒ‘ã‚¹ç”Ÿæˆ
generate_output_path() {
    local input_file=$1
    local extension=$2
    local base_output_dir=$3
    
    local basename=$(basename "$input_file")
    local filename="${basename%.*}"
    local output_file="$filename.$extension"
    
    if [[ "$ORGANIZE_OUTPUT" == "true" ]]; then
        local date_dir=$(date +%Y-%m-%d)
        local output_path="$base_output_dir/$date_dir/$output_file"
        mkdir -p "$(dirname "$output_path")"
    elif [[ -n "$base_output_dir" ]]; then
        local output_path="$base_output_dir/$output_file"
        mkdir -p "$base_output_dir"
    else
        local output_path="${input_file%.*}.$extension"
    fi
    
    echo "$output_path"
}

# å¤‰æ›å®Ÿè¡Œ
execute_conversion() {
    local file=$1
    local type=$2
    local output_file=$3
    
    # æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ãƒã‚§ãƒƒã‚¯
    if [[ "$SKIP_EXISTING" == "true" && -f "$output_file" ]]; then
        echo -e "${YELLOW}   âš ï¸  ã‚¹ã‚­ãƒƒãƒ—: $(basename "$output_file") ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™${NC}"
        return 0
    fi
    
    local start_time=$(date +%s)
    local success=false
    
    case $type in
        mp3|mp3hq)
            local quality=${QUALITY:-$MP3_QUALITY}
            if [[ "$type" == "mp3hq" && -z "$QUALITY" ]]; then
                quality="320k"
            fi
            if ffmpeg -i "$file" -vn -acodec mp3 -ab "$quality" "$output_file" -loglevel error -hide_banner 2>/dev/null; then
                success=true
            fi
            ;;
        aac)
            local quality=${QUALITY:-$AAC_QUALITY}
            if ffmpeg -i "$file" -vn -acodec aac -ab "$quality" "$output_file" -loglevel error -hide_banner 2>/dev/null; then
                success=true
            fi
            ;;
        wav)
            if ffmpeg -i "$file" -vn -acodec pcm_s16le "$output_file" -loglevel error -hide_banner 2>/dev/null; then
                success=true
            fi
            ;;
        png|pnghq)
            local dpi=${QUALITY:-$PNG_DPI}
            if [[ "$type" == "pnghq" && -z "$QUALITY" ]]; then
                dpi="300"
            fi
            if pdftoppm -png -r "$dpi" "$file" "${output_file%.*}" >/dev/null 2>&1; then
                success=true
            fi
            ;;
        jpg|jpghq)
            local dpi=${QUALITY:-$JPG_DPI}
            if [[ "$type" == "jpghq" && -z "$QUALITY" ]]; then
                dpi="300"
            fi
            if pdftoppm -jpeg -r "$dpi" "$file" "${output_file%.*}" >/dev/null 2>&1; then
                success=true
            fi
            ;;
    esac
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    if [[ "$success" == "true" ]]; then
        local output_size=$(get_file_size "$output_file")
        echo -e "${GREEN}   âœ… å®Œäº†${NC} ($(format_duration $duration)) - å‡ºåŠ›: $(format_size $output_size)"
        log_success "ãƒãƒƒãƒå¤‰æ›å®Œäº†: $file â†’ $output_file"
        
        # ãƒ•ã‚¡ã‚¤ãƒ«æ¤œè¨¼
        if [[ "$VERIFY_FILES" == "true" ]]; then
            local verify_type=""
            case $type in
                mp3|mp3hq|aac|wav) verify_type="audio" ;;
                png|pnghq|jpg|jpghq) verify_type="image" ;;
            esac
            
            if [[ -n "$verify_type" ]]; then
                if verify_file "$output_file" "$verify_type"; then
                    echo -e "${GREEN}   ğŸ” æ¤œè¨¼: OK${NC}"
                else
                    echo -e "${RED}   ğŸ” æ¤œè¨¼: ã‚¨ãƒ©ãƒ¼${NC}"
                    log_error "ãƒãƒƒãƒå¤‰æ›æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: $output_file"
                fi
            fi
        fi
        return 0
    else
        echo -e "${RED}   âŒ ã‚¨ãƒ©ãƒ¼: å¤‰æ›ã«å¤±æ•—ã—ã¾ã—ãŸ${NC}"
        log_error "ãƒãƒƒãƒå¤‰æ›ã‚¨ãƒ©ãƒ¼: $file"
        return 1
    fi
}

# è‡ªå‹•å¤‰æ›ã‚¿ã‚¤ãƒ—åˆ¤åˆ¥
detect_conversion_type() {
    local file=$1
    local ext="${file##*.}"
    
    case "${ext,,}" in
        mp4|mov|avi|mkv|flv|webm)
            echo "mp3"
            ;;
        pdf)
            echo "png"
            ;;
        *)
            echo ""
            ;;
    esac
}

# ãƒ¡ã‚¤ãƒ³å‡¦ç†
main() {
    local start_time=$(date +%s)
    
    echo -e "${PURPLE}ğŸš€ Media-to-Media ãƒãƒƒãƒå‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™${NC}"
    echo -e "${WHITE}å¤‰æ›ã‚¿ã‚¤ãƒ—: $CONVERSION_TYPE | å…¥åŠ›: $INPUT_DIR${NC}"
    if [[ -n "$OUTPUT_DIR" ]]; then
        echo -e "${WHITE}å‡ºåŠ›: $OUTPUT_DIR${NC}"
    fi
    echo -e "${WHITE}ä¸¦åˆ—å‡¦ç†: $PARALLEL_JOBS | å†å¸°: $RECURSIVE${NC}"
    echo
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§å–å¾—
    local files=()
    case $CONVERSION_TYPE in
        mp3|mp3hq|aac|wav)
            mapfile -t files < <(get_files "$INPUT_DIR" "*.mp4")
            mapfile -t temp_files < <(get_files "$INPUT_DIR" "*.mov")
            files+=("${temp_files[@]}")
            mapfile -t temp_files < <(get_files "$INPUT_DIR" "*.avi")
            files+=("${temp_files[@]}")
            ;;
        png|pnghq|jpg|jpghq)
            mapfile -t files < <(get_files "$INPUT_DIR" "*.pdf")
            ;;
        auto)
            mapfile -t files < <(get_files "$INPUT_DIR" "*.*")
            ;;
        *)
            echo -e "${RED}âŒ ã‚¨ãƒ©ãƒ¼: ä¸æ˜ãªå¤‰æ›ã‚¿ã‚¤ãƒ—: $CONVERSION_TYPE${NC}"
            exit 1
            ;;
    esac
    
    if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${YELLOW}âš ï¸  å‡¦ç†å¯¾è±¡ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ${NC}"
        exit 0
    fi
    
    echo -e "${BLUE}ğŸ“ å‡¦ç†å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«: ${#files[@]}å€‹${NC}"
    
    # Dry run ãƒ¢ãƒ¼ãƒ‰
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${CYAN}ğŸ” Dry run ãƒ¢ãƒ¼ãƒ‰ - å®Ÿéš›ã®å¤‰æ›ã¯è¡Œã„ã¾ã›ã‚“${NC}"
        echo
        for file in "${files[@]}"; do
            local type=$CONVERSION_TYPE
            if [[ "$type" == "auto" ]]; then
                type=$(detect_conversion_type "$file")
                if [[ -z "$type" ]]; then
                    echo -e "${YELLOW}âš ï¸  ã‚¹ã‚­ãƒƒãƒ—: $(basename "$file") (å¯¾å¿œã—ã¦ã„ãªã„å½¢å¼)${NC}"
                    continue
                fi
            fi
            
            local ext=""
            case $type in
                mp3|mp3hq) ext="mp3" ;;
                aac) ext="aac" ;;
                wav) ext="wav" ;;
                png|pnghq) ext="png" ;;
                jpg|jpghq) ext="jpg" ;;
            esac
            
            local output_file=$(generate_output_path "$file" "$ext" "$OUTPUT_DIR")
            echo -e "${BLUE}â†’${NC} $(basename "$file") ${CYAN}â†’${NC} $(basename "$output_file")"
        done
        return 0
    fi
    
    # å®Ÿéš›ã®å¤‰æ›å‡¦ç†
    local jobs=()
    local current=0
    local successful=0
    local failed=0
    
    for file in "${files[@]}"; do
        ((current++))
        
        local type=$CONVERSION_TYPE
        if [[ "$type" == "auto" ]]; then
            type=$(detect_conversion_type "$file")
            if [[ -z "$type" ]]; then
                echo -e "${YELLOW}ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ« ${current}/${#files[@]}: $(basename "$file")${NC}"
                echo -e "${YELLOW}   âš ï¸  ã‚¹ã‚­ãƒƒãƒ—: å¯¾å¿œã—ã¦ã„ãªã„å½¢å¼${NC}"
                ((failed++))
                continue
            fi
        fi
        
        local ext=""
        case $type in
            mp3|mp3hq) ext="mp3" ;;
            aac) ext="aac" ;;
            wav) ext="wav" ;;
            png|pnghq) ext="png" ;;
            jpg|jpghq) ext="jpg" ;;
        esac
        
        local output_file=$(generate_output_path "$file" "$ext" "$OUTPUT_DIR")
        
        local job="echo -e '${YELLOW}ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ« ${current}/${#files[@]}: $(basename "$file")${NC}' && \
                  echo -e '${BLUE}   å‡ºåŠ›å…ˆ: $(basename "$output_file")${NC}' && \
                  execute_conversion '$file' '$type' '$output_file' && echo"
        
        jobs+=("$job")
    done
    
    # ä¸¦åˆ—å®Ÿè¡Œ
    if [[ $PARALLEL_JOBS -gt 1 ]] && [[ ${#jobs[@]} -gt 1 ]]; then
        echo -e "${BLUE}ğŸš€ ä¸¦åˆ—å‡¦ç†ã§å¤‰æ›ã‚’å®Ÿè¡Œã—ã¾ã™...${NC}"
        run_parallel $PARALLEL_JOBS "${jobs[@]}"
    else
        for job in "${jobs[@]}"; do
            eval "$job"
        done
    fi
    
    # çµæœé›†è¨ˆ
    for file in "${files[@]}"; do
        local type=$CONVERSION_TYPE
        if [[ "$type" == "auto" ]]; then
            type=$(detect_conversion_type "$file")
            [[ -z "$type" ]] && continue
        fi
        
        local ext=""
        case $type in
            mp3|mp3hq) ext="mp3" ;;
            aac) ext="aac" ;;
            wav) ext="wav" ;;
            png|pnghq) ext="png" ;;
            jpg|jpghq) ext="jpg" ;;
        esac
        
        local output_file=$(generate_output_path "$file" "$ext" "$OUTPUT_DIR")
        
        if [[ -f "$output_file" ]]; then
            ((successful++))
        else
            ((failed++))
        fi
    done
    
    local end_time=$(date +%s)
    local total_duration=$((end_time - start_time))
    
    echo -e "${GREEN}ğŸ‰ ãƒãƒƒãƒå‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸï¼${NC}"
    echo -e "${WHITE}æˆåŠŸ: $successful | å¤±æ•—: $failed | ç·å‡¦ç†æ™‚é–“: $(format_duration $total_duration)${NC}"
    
    # é€šçŸ¥é€ä¿¡
    if [[ $successful -gt 0 ]]; then
        send_notification "Media-to-Media" "${successful}å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒãƒƒãƒå¤‰æ›ã—ã¾ã—ãŸ" "Glass"
    fi
    
    log_info "ãƒãƒƒãƒå‡¦ç†å®Œäº†: ã‚¿ã‚¤ãƒ—=$CONVERSION_TYPE, æˆåŠŸ=$successful, å¤±æ•—=$failed, æ™‚é–“=${total_duration}s"
}

# ä¾å­˜é–¢ä¿‚ãƒã‚§ãƒƒã‚¯
check_dependencies() {
    local deps_ok=true
    
    case $CONVERSION_TYPE in
        mp3|mp3hq|aac|wav|auto)
            if ! check_dependency "ffmpeg" "ffmpeg"; then
                deps_ok=false
            fi
            ;;
    esac
    
    case $CONVERSION_TYPE in
        png|pnghq|jpg|jpghq|auto)
            if ! check_dependency "pdftoppm" "poppler-utils"; then
                deps_ok=false
            fi
            ;;
    esac
    
    if [[ "$deps_ok" == "false" ]]; then
        echo -e "${YELLOW}macOS: brew install ffmpeg poppler${NC}"
        echo -e "${YELLOW}Ubuntu: sudo apt install ffmpeg poppler-utils${NC}"
        exit 1
    fi
}

# å®Ÿè¡Œ
check_dependencies
main 